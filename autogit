#!/usr/bin/expect --
#
#
# author stefano fattore
#
# version BETA 0.4.3

set user [exec whoami]
set supersecrets /home/$user/.autogit/supersecrets
set conffolder /home/$user/.autogit
set executable /usr/local/bin/autogit
set manpage /usr/share/man/man1/autogit.1.gz

set COMMAND 0
set command 0
set arguments ""

if {![file exists $supersecrets]} {
    puts "\[ERR\] => configuration not found! please run ./config --help"
    exit -1
}

proc complete {cmd status} {
    if { $status } {
        puts "\[SUC\] => $cmd done, quitting.."
    } else {
        puts "done."
    }
}

proc help {} {
    puts "**help here**"
    exit 0
}

proc version {} {
    puts "\033\[95m==============================================="
    puts "
                _                  _  _   
               | |                (_)| |  
   __ _  _   _ | |_   ___    __ _  _ | |_ 
  / _` || | | || __| / _ \\  / _` || || __|
 | (_| || |_| || |_ | (_) || (_| || || |_ 
  \\__,_| \\__,_| \\__| \\___/  \\__, ||_| \\__|
                             __/ |        
                            |___/         "
    puts ""
    puts "==============================================\033\[00m"
    puts ""
    puts "\033\[97m\033\[01mVersion:\033\[00m"
    puts "  0.1.0 \[BETA\]"
    puts ""
    puts "Developed by Stefano Fattore aka MastroGibbs"
    puts ""
    exit 0
}

proc uninstall {opt} {
    set action 0

    puts "==============================================="
    puts "             Autogit unistaller"
    puts "==============================================="
    puts ""

    if {[file exists $conffolder]} {
        puts "Removing installation folder"
        set ifol [exec head -n1 /home/$i/.autogit/cache]

        if { $ifol != "" } {
            exec sudo rm -fr $ifol
            set action 1
        }
    }   

    if { $opt != 0 } {
        puts "Removing conf folder.."
        exec rm -f -r $conffolder
        set action 1
    }

    puts "Unistalling autogit.."

    puts "Removing executable if exists"
    exec sudo rm -f /usr/local/bin/autogit

    puts "Removing entry for man-db if exists"
    exec sudo rm -f /usr/share/man/man1/autogit.1.gz

    puts "Elaborating trigger for man-db"
    spawn -noecho sudo mandb

    if { $action } {
        complete $cmd
    } else {
        puts "Nothing to do, quitting"
    }

    exit 0
}

proc parseargs {argc argv} {
    if { $argc == 0 } { help }

    set command [lindex $argv 0]
    set cmd 0

    switch -regexp -- $command {
        {(^git$|^ssh$)} {}

        {(^\-h$|^\-\-help$)} { help }

        {(^\-v$|^\-\-version$)} { version }

        {(^uninstall$)} { 
            set opt 0
            if { $argc == 2 } {
                set tmp [lindex $argv 1]
                if { $tmp == "--purge" } {
                    set opt [lindex $argv 1]
                } else {
                    puts "\[ERR\] => unknown option '$tmp'\nrun autogit --help\nquitting.."
                    exit -1
                }
            }
            uninstall $opt
        }

        default {
            puts "\[ERR\] => command '$command' not valid, quitting"
            exit -1
        }
    }

    if { $argc == 1 } { help }

    for { set iter 1 } { $iter < $argc } { incr iter } {
        set curr [lindex $argv $iter]

        set err_msg "\[ERR\] => cannot use command/option '$curr' here\nrun autogit --help\nquitting.."

        switch -regexp -- $curr {
            {(^git$|^ssh$|^uninstall$)} { puts $err_msg; exit -1 }

            {(^\-h$|^\-\-help$)} { help }
    
            {(^\-v$|^\-\-version$)} { version }

            default { 
                if { $command == "git" } {
                    switch -regexp -- $curr {
                        {(^saio$)} {
                            if { $iter != 1 } { puts $err_msg; exit -1 }
                            if { $argc == 2 } { puts $err_msg; exit -1 }
                            set cmd $curr
                        }

                        default {}
                    }

                } elseif { $command == "ssh" } {
                    switch -regexp -- $curr {
                        default {}
                    }
                }
            }
        }
    }

    set other_args [lrange $argv 2 end]
    set result "$command $cmd \"$other_args\""
    return $result
}

lassign [parseargs $argc $argv] COMMAND command arguments

switch -regexp -- $COMMAND {
    {(^git$)} {
        set USERNAME [exec -- sh -c "tail -f $supersecrets | sed \"/^-?-$/ q\" | head -n -1 | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$conffolder/conf/encr"]
        set TOKEN [exec cat $supersecrets | sed -n -e "/-?-/,\$p" | sed "1d" | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$conffolder/conf/encr]

        switch -regexp -- $command {
            {(^saio$)} {
                # simple all in one

                set status 0

                spawn -noecho git add .
                spawn -noecho git commit -m "$args"
            
                spawn -noecho git push
                expect {
                    timeout { puts "No auth required"; puts "done"; exit 1 }
                    eof { puts "No auth required"; puts "done"; exit 1 }
                    "*atal:" { send_user "\n\[ERR\] => error incomes, quitting..\n"; exit -1 }
                    "Username for 'https://github.com':"
                }
                send "$USERNAME\r"
                expect {
                    timeout { puts "No auth required"; puts "done"; exit 1 }
                    eof { puts "No auth required"; puts "done"; exit 1 }
                    "Password for 'https://$USERNAME@github.com':"
                }
                send "$TOKEN\r"
                interact
                set status 1 
            
                complete $cmd $status;
            
                exit 0
            }

            default {
                # default git command 

                set status 0

                spawn -noecho git $cmd {*}$args
                expect {
                    timeout { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
                    eof { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
                    "*atal:" { send_user "\n\[ERR\] => error incomes, quitting..\n"; exit -1 }
                    "Username for 'https://github.com':"
                }
                send "$USERNAME\r"
                expect {
                    timeout { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
                    eof { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
                    "Password for 'https://$USERNAME@github.com':"
                }
                send "$TOKEN\r"
                interact

                set status 1
                
                complete $cmd $status;
                
                exit 0
            }
        }
    }

    {(^ssh$)} {
        puts "**ssh impl here**"
        exit 0
    }

    default {
        # catch everythings, no op
    } 

}



