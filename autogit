#!/usr/bin/expect --
#
#
# author stefano fattore
#
# version BETA 0.4

proc complete {cmd} {
    if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" || $cmd == "saio" } {
        puts "\[SUC\] => $cmd done, quitting.."
    } else {
        puts "done."
    }
}


proc help_section {arguments} {
    if { [llength $arguments] == 2 } {
        set cmd_help [lindex $arguments 1]
        if { $cmd_help == "git" } {
            spawn -noecho man git
            interact
            exit 0
        }
        spawn -noecho man git-$cmd_help
        interact
        exit 0
    }

    puts "\033\[95m==============================================="
    puts "
                _                  _  _   
               | |                (_)| |  
   __ _  _   _ | |_   ___    __ _  _ | |_ 
  / _` || | | || __| / _ \\  / _` || || __|
 | (_| || |_| || |_ | (_) || (_| || || |_ 
  \\__,_| \\__,_| \\__| \\___/  \\__, ||_| \\__|
                             __/ |        
                            |___/         "
    puts ""
    puts "==============================================\033\[00m"
    puts ""
    puts "\033\[97m\033\[01mDescription:\033\[00m"
    puts "      Wraps up the git command set by adding handy features for lazy linux developers.
      Essentially this tool automatically detects the request for 
      username and password (token) and inserts them for you.
      Read a file present in a configuration folder in the home, containing user data."
    puts ""
    puts "\033\[97m\033\[01mCommands:\033\[00m"
    puts "      saio <comment>
            Must be combined with a comment necessarily enclosed in double quotes.
            Otherwise it will have undefined behavior,
            or a commit will be presented with the first word given after 'saio' command.
            An 'add .' will be made, 
            followed by 'commit -m <comment>' 
            and finally by simple 'push'."
    puts ""
    puts "      uninstall \[--purge\]
            Uninstall autogit. It can be combined with --purge option to remove conf folder."
    puts ""
    puts "\"like git command but more lazier\""
    puts ""
    puts "run \[-h|--help\] <git command> to view his man page"
    puts ""
    exit 0
}

proc parseargs {argc argv} {
    set i 0
    set warn 0
    set saio 0
    set unin 0

    foreach {val} $argv {
        set err "\[ERR\] => cannot use '$val' in this way, run autogit --help"

        if { $val == "saio" && $argc != 1 } {
            set saio 1
        }

        if { $val == "uninstall" && $argc != 0 } {
            set unin 1
        }

        if { $val == "--purge" && $i == 0 } {
            puts $err; 
            exit -1 
        } elseif { $val == "uninstall" && $i != 0 } {
            puts $err; 
            exit -1 
        } elseif { $val == "saio" && $i != 0 } {
            puts $err; 
            exit -1 
        } elseif { $val == "saio" && $i == 0 && $argc == 1 } {
            puts $err; 
            exit -1 
        } elseif { $argc != 1 && $saio && $unin && !$warn } {
            set warn 0
        } elseif { $val != "-v" && $val != "--version" && $val != "-h" && $val != "--help" && !$saio && !$unin } {
            set warn 1
        }
        set i [expr {$i + 1}]
    }

    if { $warn } {
        puts "\[WARN\] => unknown command/option '$argv' for autogit, proceeding with git"
    }
    
}


if { [llength $argv] == 0 } {
    puts "\[WARN\] => args required, running help.."
    sleep 1
    help_section $argv
} else {
    parseargs $argc $argv
}


set args [lrange $argv 1 end]
set cmd [lindex $argv 0]
set i [exec whoami]
set conffile /home/$i/.autogit/supersecrets
set conffolder /home/$i/.autogit


if { $cmd == "--version" || $cmd == "-v" } {
    puts "\033\[95m==============================================="
    puts "
                _                  _  _   
               | |                (_)| |  
   __ _  _   _ | |_   ___    __ _  _ | |_ 
  / _` || | | || __| / _ \\  / _` || || __|
 | (_| || |_| || |_ | (_) || (_| || || |_ 
  \\__,_| \\__,_| \\__| \\___/  \\__, ||_| \\__|
                             __/ |        
                            |___/         "
    puts ""
    puts "==============================================\033\[00m"
    puts ""
    puts "\033\[97m\033\[01mVersion:\033\[00m"
    puts "  0.4 \[BETA\]"
    puts ""
    puts "Developed by Stefano Fattore aka MastroGibbs"
    puts ""
    exit 0
}


if { $cmd == "uninstall" } {
    puts "==============================================="
    puts "             Autogit unistaller"
    puts "==============================================="
    puts ""
    if { [llength $argv] == 2 } {
        set purge [lindex $argv 1]
        if { $purge == "--purge" || $purge == "-p" } {
            if {![file exists $conffile]} {
                puts "Configuration not found! cannot execute --purge option!"
            } else {
                puts "Removing conf folder.."
                exec rm -f -r $conffolder
            }
        } else {
            puts "Option '$purge' not recognized. Proceed to uninstall autogit."
        }
    }

    puts "Unistalling autogit.."
    puts "Removing soft link"
    exec sudo rm -f /usr/local/bin/autogit

    if {[file exists $conffile]} {
        puts "Removing installation folder"
        set ifol [exec head -n1 /home/$i/.autogit/cache]
        exec sudo rm -fr $ifol  
    }    

    puts "Removing entry for man-db"
    exec sudo rm -f /usr/share/man/man1/autogit.1.gz

    puts "Elaborating trigger for man-db"
    spawn -noecho sudo mandb

    complete $cmd

    exit 0
}


if { $cmd == "--help" || $cmd == "-h" } {
    help_section $argv
}

if {![file exists $conffile]} {
    puts "configuration not found! please run autogitconfigure!"
    exit -1
}
set USERNAME [exec head -n 1 $conffile | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$conffolder/conf/encr]
set TOKEN [exec tail -n 2 $conffile | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$conffolder/conf/encr]


if { $cmd == "saio" } {
    if { [llength $argv] == 1 } {
        puts "\[ERR\] => args required with 'saio' command, aborting.."
        puts "run with option --help for tips"
        exit -1
    }

    set cmt [lrange $argv 1 end]

    spawn -noecho git add .
    spawn -noecho git commit -m "$cmt"

    spawn -noecho git push
    expect {
        timeout { puts "No auth required"; puts "done"; exit 1 }
        eof { puts "No auth required"; puts "done"; exit 1 }
        "*atal:" { send_user "\n\[ERR\] => error incomes, quitting..\n"; exit -1 }
        "Username for 'https://github.com':"
    }
    send "$USERNAME\r"
    expect {
        timeout { puts "No auth required"; puts "done"; exit 1 }
        eof { puts "No auth required"; puts "done"; exit 1 }
        "Password for 'https://$USERNAME@github.com':"
    }
    send "$TOKEN\r"
    interact

    complete $cmd;

    exit 0
}


spawn -noecho git $cmd {*}$args
expect {
    timeout { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
    eof { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
    "*atal:" { send_user "\n\[ERR\] => error incomes, quitting..\n"; exit -1 }
    "Username for 'https://github.com':"
}
send "$USERNAME\r"
expect {
    timeout { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
    eof { if { $cmd == "push" || $cmd == "pull" || $cmd == "clone" } { puts "No auth required" }; complete $cmd; exit 1 }
    "Password for 'https://$USERNAME@github.com':"
}
send "$TOKEN\r"
interact

complete $cmd;

exit 0



