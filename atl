#!/usr/bin/expect --
#
#
# author stefano fattore
#
# version BETA 0.1.2

set user [exec whoami]
set gitss /home/$user/.atl/git/ss
set gitpw /home/$user/.atl/git/conf/encr
set manpage /usr/share/man/man1/atl.1.gz
set confdir /home/$user/.atl
set executable /usr/local/bin/atl

set COMMAND 0
set command 0
set arguments ""

if {![file exists $confdir/cache]} {
    puts "\[ERR\] => configuration not found\nrun ./config --help"
    exit -1
}

proc complete {command status} {
    if { $status } {
        puts "\[SUC\] => $command done, quitting.."
    } else {
        puts "done."
    }
}

proc help {} {
    puts "**help here**"
    exit 0
}

proc version {} {
    puts "\033\[95m==============================================="
    puts "
                _                  _  _   
               | |                (_)| |  
   __ _  _   _ | |_   ___    __ _  _ | |_ 
  / _` || | | || __| / _ \\  / _` || || __|
 | (_| || |_| || |_ | (_) || (_| || || |_ 
  \\__,_| \\__,_| \\__| \\___/  \\__, ||_| \\__|
                             __/ |        
                            |___/         "
    puts ""
    puts "==============================================\033\[00m"
    puts ""
    puts "\033\[97m\033\[01mVersion:\033\[00m"
    puts "  0.1.2 \[BETA\]"
    puts ""
    puts "Developed by Stefano Fattore aka MastroGibbs"
    puts ""
    exit 0
}

proc uninstall {command opt} {
    set action 0
    set user [exec whoami]
    set confdir /home/$user/.atl

    puts "==============================================="
    puts "             Atl unistaller"
    puts "==============================================="
    puts ""

    if {[file exists $confdir]} {
        puts "Removing installation folder"
        set ifol [exec head -n1 /home/$user/.atl/cache]

        if { $ifol != "" } {
            exec sudo rm -fr $ifol
            set action 1
        }
    }   

    if { $opt != 0 } {
        puts "Removing conf folder.."
        exec rm -f -r $confdir
        set action 1
    }

    puts "Unistalling atl.."

    puts "Removing executable if exists"
    exec sudo rm -f /usr/local/bin/atl

    puts "Removing entry for man-db if exists"
    exec sudo rm -f /usr/share/man/man1/atl.1.gz

    puts "Elaborating trigger for man-db"
    spawn -noecho sudo mandb

    if { $action } {
        complete $command
    } else {
        puts "Nothing to do, quitting"
    }

    exit 0
}

proc config {opt} {
    set err_msg "\[ERR\] => configuration not found\nquitting.."
    set arg 0
    set user [exec whoami]
    set confdir /home/$user/.atl

    switch -regexp -- $opt {
        {(^git$)} {
            set arg "--github"
        }
        
        {(^ssh$)} {
            set arg "--ssh"
        }

        default {
            # dummy 
            exit -1
        }
    }

    if {[file exists $confdir]} {
        set ifol [exec head -n1 /home/$user/.atl/cache]

        if { $ifol != "" } {
            set ifol ${ifol}bin/config
            if {[file exists $ifol]} {
                spawn -noecho $ifol $arg
                interact
                exit 0
            } else {
                puts "\[ERR\] => no script found\nquitting.."
                exit -1
            }
        } else {
            puts $err_msg
            exit -1
        }
    } else {
        puts $err_msg
        exit -1
    }
}

proc parseargs {argc argv} {
    if { $argc == 0 } { help }

    set COMMAND [lindex $argv 0]
    set command 0

    switch -regexp -- $COMMAND {
        {(^git$|^ssh$)} {}

        {(^\-h$|^\-\-help$)} { help }

        {(^\-v$|^\-\-version$)} { version }

        {(^uninstall$)} { 
            set opt 0
            if { $argc == 2 } {
                set tmp [lindex $argv 1]
                if { $tmp == "--purge" } {
                    set opt [lindex $argv 1]
                } else {
                    puts "\[ERR\] => unknown option '$tmp'\nrun atl --help\nquitting.."
                    exit -1
                }
            }
            uninstall $COMMAND $opt
        }

        {(^config$)} {
            set opt 0

            if { $argc < 2 } { puts "\[ERR\] => must specify configure option\nquitting.."; exit -1 }

            set tmp [lindex $argv 1]

            switch -regexp -- $tmp {
                {(^git$|^ssh$)} {
                    set opt $tmp
                }

                default {
                    puts "Unknown option '$tmp'\nquitting.."
                    exit -1
                }
            }

            config $opt
        }

        default {
            puts "\[ERR\] => command '$COMMAND' not valid\nquitting"
            exit -1
        }
    }

    if { $argc == 1 } { help }

    for { set iter 1 } { $iter < $argc } { incr iter } {
        set curr [lindex $argv $iter]

        set err_msg "\[ERR\] => cannot use command/option '$curr' here\nrun atl --help\nquitting.."

        switch -regexp -- $curr {
            {(^git$|^ssh$|^uninstall$)} { puts $err_msg; exit -1 }

            {(^\-h$|^\-\-help$)} { help }
    
            {(^\-v$|^\-\-version$)} { version }

            default { 
                if { $COMMAND == "git" } {
                    switch -regexp -- $curr {
                        {(^saio$)} {
                            if { $iter != 1 } { puts $err_msg; exit -1 }
                            if { $argc == 2 } { puts $err_msg; exit -1 }
                            set command $curr
                        }

                        default {
                            if { $iter == 1 } { set command $curr }
                        }
                    }

                } elseif { $COMMAND == "ssh" } {
                    switch -regexp -- $curr {
                        default {
                            if { $iter == 1 } { set command $curr }
                        }
                    }
                }
            }
        }
    }

    set result "$COMMAND $command"
    return $result
}

# ARGS parsing area
lassign [parseargs $argc $argv] COMMAND command

if { $argc > 2 } {
    set arguments [lrange $argv 2 end]
}
# ARGS parsing area END


# CORE impl
switch -regexp -- $COMMAND {
    {(^git$)} {
        if {![file exists $gitss] && ![file exists $gitpw]} {
            puts "\[ERR\] => git configuration not found\nrun ./config --help"
            exit -1
        }

        set USERNAME [exec -- sh -c "tail -f $gitss | sed \"/^-?-$/ q\" | head -n -1 | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$gitpw"]
        set TOKEN [exec cat $gitss | sed -n -e "/-?-/,\$p" | sed "1d" | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$gitpw]

        switch -regexp -- $command {
            {(^saio$)} {
                # simple all in one

                set status 0

                spawn -noecho git add .
                spawn -noecho git commit -m "$arguments"
            
                spawn -noecho git push
                expect {
                    timeout { puts "Timeout reached, quitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "*atal:" { send_user "\n\[ERR\] => error incomes, quitting..\n"; exit -1 }
                    "Username for 'https://github.com':"
                }
                send "$USERNAME\r"
                expect {
                    timeout { puts "Timeout reached, quitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "Password for 'https://$USERNAME@github.com':"
                }
                send "$TOKEN\r"
                interact
                set status 1 
            
                complete $command $status;
            
                exit 0
            }

            default {
                # default git command 

                set status 0

                spawn -noecho git $command {*}$arguments
                expect {
                    timeout { puts "Timeout reached, quitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "*atal:" { send_user "\n\[ERR\] => error incomes, quitting..\n"; exit -1 }
                    "Username for 'https://github.com':"
                }
                send "$USERNAME\r"
                expect {
                    timeout { puts "Timeout reached, quitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "Password for 'https://$USERNAME@github.com':"
                }
                send "$TOKEN\r"
                interact

                set status 1
                
                complete $command $status;
                
                exit 0
            }
        }
    }

    {(^ssh$)} {
        puts "**ssh impl here**"
        exit 0
    }

    default {
        # catch everythings
        exit -1
    } 

}
# CORE impl END


