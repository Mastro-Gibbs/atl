#!/usr/bin/expect --
#
#
# author stefano fattore
#
# version BETA 0.1.3

set user [exec whoami]
set gitss /home/$user/.atl/git/ss
set gitpw /home/$user/.atl/git/conf/encr
set manpage /usr/share/man/man1/atl.1.gz
set confdir /home/$user/.atl
set executable /usr/local/bin/atl

set COMMAND 0
set command 0
set arguments ""

if {![file exists $confdir/cache]} {
    puts "\[ERR\] => configuration not found\nrun ./config --help"
    exit -1
}

proc complete {command status} {
    if { $status } {
        puts "\[SUC\] => $command done\nquitting.."
    } else {
        puts "done."
    }
}

proc signature {sign} {
    puts "\033\[95m==============================================="
    puts "   
         $sign

          █████╗ ████████╗██╗     
         ██╔══██╗╚══██╔══╝██║     
         ███████║   ██║   ██║     
         ██╔══██║   ██║   ██║     
         ██║  ██║   ██║   ███████╗
         ╚═╝  ╚═╝   ╚═╝   ╚══════╝"
    puts ""
    puts "==============================================\033\[00m"
    puts ""
}

proc help {} {
    set sign "Helper for"
    signature $sign
    exit 0
}

proc version {} {
    set sign "Version for"
    signature $sign

    puts "\033\[97m\033\[01mVersion:\033\[00m"
    puts "  0.1.3 \[BETA\]"
    puts ""
    puts "Developed by Stefano Fattore aka MastroGibbs"
    puts ""
    exit 0
}

proc uninstall {opt} {
    set sign "Uninstaller for"
    signature $sign

    set user [exec whoami]
    set confdir /home/$user/.atl

    set err_msg "\[ERR\] => configuration not found\nquitting.."

    if {[file exists $confdir]} {
        set ifol [exec head -n1 /home/$user/.atl/cache]

        if { $ifol != "" } {
            set ifol ${ifol}bin/uninstall
            if {[file exists $ifol]} {
                spawn -noecho $ifol $opt
                interact
                exit 0
            } else {
                puts "\[ERR\] => no script found\nquitting.."
                exit -1
            }
        } else {
            puts $err_msg
            exit -1
        }
    } else {
        puts $err_msg
        exit -1
    }
}

proc config {opt} {
    set sign "Configure process for"
    signature $sign

    set err_msg "\[ERR\] => configuration not found\nquitting.."
    set arg 0
    set user [exec whoami]
    set confdir /home/$user/.atl

    switch -regexp -- $opt {
        {(^git$)} {
            set arg "--github"
        }
        
        {(^ssh$)} {
            set arg "--ssh"
        }

        default {
            # dummy 
            exit -1
        }
    }

    if {[file exists $confdir]} {
        set ifol [exec head -n1 /home/$user/.atl/cache]

        if { $ifol != "" } {
            set ifol ${ifol}bin/config
            if {[file exists $ifol]} {
                spawn -noecho $ifol $arg
                interact
                exit 0
            } else {
                puts "\[ERR\] => no script found\nquitting.."
                exit -1
            }
        } else {
            puts $err_msg
            exit -1
        }
    } else {
        puts $err_msg
        exit -1
    }
}

proc parseargs {argc argv} {
    if { $argc == 0 } { help }

    set COMMAND [lindex $argv 0]
    set command 0

    switch -regexp -- $COMMAND {
        {(^git$|^ssh$)} {}

        {(^\-h$|^\-\-help$)} { help }

        {(^\-v$|^\-\-version$)} { version }

        {(^uninstall$)} { 
            set opt 0
            if { $argc == 2 } {
                set tmp [lindex $argv 1]
                if { $tmp == "--purge" } {
                    set opt [lindex $argv 1]
                } else {
                    puts "\[ERR\] => unknown option '$tmp'\n\trun atl --help\nquitting.."
                    exit -1
                }
            }
            uninstall $opt
        }

        {(^config$)} {
            set opt 0

            if { $argc < 2 } { puts "\[ERR\] => must specify configure option\nquitting.."; exit -1 }

            set tmp [lindex $argv 1]

            switch -regexp -- $tmp {
                {(^git$|^ssh$)} {
                    set opt $tmp
                }

                default {
                    puts "Unknown option '$tmp'\nquitting.."
                    exit -1
                }
            }

            config $opt
        }

        default {
            puts "\[ERR\] => command '$COMMAND' not valid\nquitting"
            exit -1
        }
    }

    if { $argc == 1 } { help }

    for { set iter 1 } { $iter < $argc } { incr iter } {
        set curr [lindex $argv $iter]

        set err_msg "\[ERR\] => cannot use command/option '$curr' here\n\trun atl --help\nquitting.."

        switch -regexp -- $curr {
            {(^git$|^ssh$|^uninstall$)} { puts $err_msg; exit -1 }

            {(^\-h$|^\-\-help$)} { help }
    
            {(^\-v$|^\-\-version$)} { version }

            default { 
                if { $COMMAND == "git" } {
                    switch -regexp -- $curr {
                        {(^saio$)} {
                            if { $iter != 1 } { puts $err_msg; exit -1 }
                            if { $argc == 2 } { puts $err_msg; exit -1 }
                            set command $curr
                        }

                        default {
                            if { $iter == 1 } { set command $curr }
                        }
                    }

                } elseif { $COMMAND == "ssh" } {
                    switch -regexp -- $curr {
                        default {
                            if { $iter == 1 } { set command $curr }
                        }
                    }
                }
            }
        }
    }

    set result "$COMMAND $command"
    return $result
}

# ARGS parsing area
lassign [parseargs $argc $argv] COMMAND command

if { $argc > 2 } {
    set arguments [lrange $argv 2 end]
}
# ARGS parsing area END


# CORE impl
switch -regexp -- $COMMAND {
    {(^git$)} {
        if {![file exists $gitss] && ![file exists $gitpw]} {
            puts "\[ERR\] => git configuration not found\n\trun atl config git"
            exit -1
        }

        set USERNAME [exec -- sh -c "tail -f $gitss | sed \"/^-?-$/ q\" | head -n -1 | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$gitpw"]
        set TOKEN [exec cat $gitss | sed -n -e "/-?-/,\$p" | sed "1d" | openssl aes-256-cbc -d -a -pbkdf2 -salt -pass file:$gitpw]

        switch -regexp -- $command {
            {(^saio$)} {
                # simple all in one

                set status 0

                spawn -noecho git add .
                spawn -noecho git commit -m "$arguments"
            
                spawn -noecho git push
                expect {
                    timeout { puts "Timeout reached\nquitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "*atal:" { send_user "\n\[ERR\] => error incomes\nquitting.."; exit -1 }
                    "Username for 'https://github.com':"
                }
                send "$USERNAME\r"
                expect {
                    timeout { puts "Timeout reached\nquitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "Password for 'https://$USERNAME@github.com':"
                }
                send "$TOKEN\r"
                interact
                set status 1 
            
                complete $command $status;
            
                exit 0
            }

            default {
                # default git command 

                set status 0

                spawn -noecho git $command {*}$arguments
                expect {
                    timeout { puts "Timeout reached\nquitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "*atal:" { send_user "\n\[ERR\] => error incomes\nquitting.."; exit -1 }
                    "Username for 'https://github.com':"
                }
                send "$USERNAME\r"
                expect {
                    timeout { puts "Timeout reached\nquitting.."; exit -1 }
                    eof { complete $command $status; exit 1 }
                    "Password for 'https://$USERNAME@github.com':"
                }
                send "$TOKEN\r"
                interact

                set status 1
                
                complete $command $status;
                
                exit 0
            }
        }
    }

    {(^ssh$)} {
        puts "**ssh impl here**"
        exit 0
    }

    default {
        # catch everythings
        exit -1
    } 

}
# CORE impl END


